#include "bitis_lib.h"
#include <optional>

// Enums
{%+ for ce in d.enums ~%}
{%- if let Some(comment_impl) = ce.comment -%}
///{{comment_impl}}
{%- endif -%}
namespace {{ ce.name }}Enum {
{%- for cv in ce.values +%}
    ENUM_INSTANCE({{ cv|pascal_case }});
{%- endfor %}
}
typedef BitisEnum<bitis_helper::Collector<{%- for cv in ce.values %}
    {{ ce.name }}Enum::{{ cv|pascal_case }}{% if !loop.last %}, {% endif %}{%- endfor %}
>, {{ce.bit_size}}> {{ ce.name }};
{%- endfor -%}

{# *****************************************************************#}
{# *****************************************************************#}
// Enums for oneof
{%+ for (_, coo) in d.oos -%}
struct {{ coo.name }}  {
    {%- for ca in coo.attributes %}
    struct OO_{{ca.base.name|pascal_case}} {
        static constexpr auto name = "{{ca.base.name|pascal_case}}"; typedef {{ ca.rust_type_str|safe}} Type; };
    {%- endfor %}

    typedef BitisEnum<bitis_helper::Collector<{%- for ca in coo.attributes %}
        OO_{{ca.base.name|pascal_case}}{% if !loop.last %}, {% endif %}{%- endfor %}
    >, {{coo.dyn_bits}}> OOEnum;

    OOEnum oo_selector;
//    union {
//        char _base;{%- for ca in coo.attributes %}
//        OO_{{ca.base.name|pascal_case}}::OOType {{ca.base.name}};
//        {%- endfor %}
//    } oo;
    oneof_helper::UnionT<
        {% for ca in coo.attributes -%}OO_{{ca.base.name|pascal_case}}::OOType{% if !loop.last %}, {% endif %}{%- endfor %}
    > oo_value;

    {{ coo.name }}() : oo_selector(), oo_value() {}

    template<typename OOT>
    {{ coo.name }} set_oo(typename OOT::OOType v) {
        static_assert(oneof_helper::ContainsType<OOT, OOEnum::EnumCollector>::value);
        oo_selector.set_enum<OOT>();
        oo_value.set(v);
        return *this;
    }
    template<typename OOT>
    OOT *get_oo() {
        static_assert(oneof_helper::ContainsType<OOT, OOEnum::EnumCollector>::value);
        if(oo_selector.is_enum<OOT>())
            return oo_value.get<OOT>();
        return nullptr;
    }

    std::size_t serialize(BitisSerializer &ser) const {
        return oneof_helper::oneof_serialize(this, ser);
    }
    void print(const int16_t indent=0) {
        printf("Oneof ");
        oneof_helper::oneof_print(this, (indent>=0) ? indent + 2 : indent, oo_enums);
    }
};
{%- endfor %}

{# *****************************************************************#}
{# *****************************************************************#}
// Messages
{% for cm in d.msgs ~%}
{%- if let Some(comment_impl) = cm.comment -%}
///{{comment_impl}}
{%- endif -%}
struct {{cm.name|pascal_case}} {
    static const char *msg_attr[];

{%- for ca in cm.attributes %}
    typedef {% include "data_object_attr_type.cpp.jinja" %} {{ca.base.name|pascal_case}}_T;
{%- endfor %}

    typedef message_helper::MessageT<
        {% for ca in cm.attributes +%}{{ca.base.name|pascal_case}}_T{% if !loop.last %}, {% endif %} {%- endfor %}
    > MsgT;
{%+ for ca in cm.attributes -%}
    {% include "data_object_attr.cpp.jinja" -%}
{%- endfor %}

    std::size_t serialize(BitisSerializer &ser) const {
        return message_helper::msg_serialize(this, ser);
    }
    static bitis_helper::BitiaDeserializerHelper<{{cm.name|pascal_case}}> deserialize(BitisDeserializer &des) {
        return message_helper::msg_deserialize<{{cm.name|pascal_case}}>(des);
    }

    void print(int16_t indent=0) {
        printf("{{cm.name|pascal_case}}{ ");
        if (indent>=0) printf("\n");
        message_helper::msg_print(this, (indent>=0) ? (2 + indent) : indent, msg_attr);
        print_indent(indent); printf("}");
        // if (indent>=0) printf("\n");
    }
};
const char *{{cm.name|pascal_case}}::msg_attr[] = { {%- for ca in cm.attributes -%}"{{ca.base.name}}"{% if !loop.last %}, {% endif %}{%- endfor -%}};

{% endfor %}

